<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Onyx Casino | Physics Engine</title>
    
    <script type="text/javascript" src="https://cdn.jsdelivr.net/npm/brython@3.12.0/brython.min.js"></script>
    <script type="text/javascript" src="https://cdn.jsdelivr.net/npm/brython@3.12.0/brython_stdlib.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/4.1.1/animate.min.css"/>
    <script src="https://cdn.jsdelivr.net/npm/canvas-confetti@1.6.0/dist/confetti.browser.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700;900&family=Roboto+Mono:wght@500&display=swap" rel="stylesheet">

    <style>
        :root {
            --onyx: #0a0a0a;
            --gold: #d4af37;
            --gold-glow: #ffd700;
            --neon-blue: #00f3ff;
            --danger: #ff2a2a;
            --panel-bg: rgba(20, 20, 20, 0.95);
        }

        body {
            font-family: 'Cinzel', serif;
            margin: 0;
            background: radial-gradient(circle at center, #1a1a1a 0%, #000000 100%);
            color: white;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            overflow: hidden;
        }

        .casino-frame {
            position: relative;
            width: 100%;
            max-width: 400px;
            background: var(--panel-bg);
            border: 2px solid #333;
            border-radius: 30px;
            padding: 2rem;
            box-shadow: 
                0 0 60px rgba(0,0,0,0.8),
                inset 0 0 20px rgba(212, 175, 55, 0.1);
            backdrop-filter: blur(10px);
        }

        /* --- DISPLAY DE PUNTOS --- */
        .hud-top {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            border-bottom: 1px solid #333;
            padding-bottom: 15px;
        }

        .score-box { text-align: left; }
        .score-val { font-size: 1.8rem; font-weight: 900; color: var(--gold-glow); text-shadow: 0 0 10px rgba(212,175,55,0.4); }
        .score-label { font-size: 0.7rem; color: #888; font-family: 'Roboto Mono', monospace; }

        .streak-badge {
            background: linear-gradient(135deg, #222, #000);
            border: 1px solid #444;
            padding: 5px 12px;
            border-radius: 8px;
            font-size: 0.8rem;
            color: #666;
            transition: 0.3s;
        }
        .streak-active {
            border-color: var(--neon-blue);
            color: var(--neon-blue);
            box-shadow: 0 0 10px rgba(0, 243, 255, 0.3);
            font-weight: bold;
        }

        /* --- CARRETE MEJORADO --- */
        #viewport {
            position: relative;
            width: 180px;
            height: 260px;
            margin: 0 auto;
            border-radius: 10px;
            border: 4px solid #222;
            background: #000;
            box-shadow: inset 0 0 30px #000;
            overflow: hidden;
        }

        /* Sombras de profundidad (Cilindro) */
        #viewport::before {
            content: '';
            position: absolute;
            top: 0; left: 0; right: 0; height: 100%;
            background: linear-gradient(180deg, 
                rgba(0,0,0,1) 0%, 
                rgba(0,0,0,0.6) 15%, 
                rgba(0,0,0,0) 40%, 
                rgba(0,0,0,0) 60%, 
                rgba(0,0,0,0.6) 85%, 
                rgba(0,0,0,1) 100%);
            z-index: 5;
            pointer-events: none;
        }

        /* L√≠nea de Pago (L√°ser) */
        .payline {
            position: absolute;
            top: 50%; left: -10px; right: -10px;
            height: 2px;
            background: rgba(255, 0, 0, 0.7);
            box-shadow: 0 0 15px var(--danger);
            z-index: 6;
            transform: translateY(-50%);
        }
        .payline::after { /* Tri√°ngulo indicador */
            content: '‚óÄ';
            position: absolute;
            right: 5px; top: -11px;
            color: var(--danger);
            font-size: 18px;
        }

        canvas { display: block; width: 100%; height: 100%; }

        /* --- CONTROLES --- */
        .control-panel { margin-top: 25px; }

        .bet-input-group {
            display: grid;
            grid-template-columns: 1fr 2fr;
            gap: 10px;
            margin-bottom: 15px;
        }

        input, select {
            background: #111;
            border: 1px solid #444;
            color: white;
            padding: 12px;
            border-radius: 8px;
            font-family: 'Roboto Mono', monospace;
            text-align: center;
            outline: none;
        }
        input:focus { border-color: var(--gold); }

        .btn-grid {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 8px;
            margin-bottom: 15px;
        }

        .btn-opt {
            background: #1a1a1a;
            border: 1px solid #333;
            color: #aaa;
            padding: 10px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.75rem;
            transition: 0.2s;
        }
        .btn-opt:hover { background: #252525; }
        .btn-opt.active {
            background: var(--gold);
            color: black;
            font-weight: bold;
            box-shadow: 0 0 15px rgba(212,175,55,0.4);
            border-color: var(--gold);
        }

        #btn-spin {
            width: 100%;
            padding: 18px;
            background: linear-gradient(180deg, #d4af37 0%, #a67c00 100%);
            border: none;
            border-radius: 8px;
            color: #1a0f00;
            font-weight: 900;
            font-size: 1.2rem;
            text-transform: uppercase;
            letter-spacing: 2px;
            cursor: pointer;
            box-shadow: 0 5px 15px rgba(0,0,0,0.5);
            position: relative;
            overflow: hidden;
            transition: transform 0.1s;
        }
        #btn-spin:active { transform: scale(0.98); }
        
        /* Efecto de brillo en el bot√≥n */
        #btn-spin::after {
            content: '';
            position: absolute;
            top: -50%; left: -50%; width: 200%; height: 200%;
            background: linear-gradient(45deg, transparent, rgba(255,255,255,0.3), transparent);
            transform: rotate(45deg);
            animation: shine 3s infinite;
        }

        @keyframes shine { 0% { left: -100%; } 20% { left: 100%; } 100% { left: 100%; } }

        .status-msg {
            margin-top: 15px;
            font-family: 'Roboto Mono', monospace;
            font-size: 0.85rem;
            min-height: 20px;
            color: var(--gold-light);
        }

        .actions-secondary {
            display: flex;
            justify-content: space-between;
            margin-top: 15px;
            font-size: 0.8rem;
        }
        .link-action { color: #666; cursor: pointer; text-decoration: underline; }
        .link-action:hover { color: var(--gold); }

    </style>
</head>
<body onload="brython()">

<div class="casino-frame animate__animated animate__fadeInUp">
    
    <div class="hud-top">
        <div class="score-box">
            <div class="score-label">SALDO DISPONIBLE</div>
            <div class="score-val" id="display-puntos">1000</div>
        </div>
        <div class="streak-badge" id="display-streak">RACHA: x1.0</div>
    </div>

    <div id="viewport">
        <div class="payline"></div>
        <canvas id="reel-canvas" width="180" height="260"></canvas>
    </div>

    <div class="control-panel">
        <p class="status-msg" id="mensaje">Mesa abierta. Haga su apuesta.</p>
        
        <div class="bet-input-group">
            <input type="number" id="input-monto" value="50" min="10" step="10">
            <select id="input-subopcion"></select>
        </div>

        <div class="btn-grid">
            <button class="btn-opt active" id="btn-exacto">N√öMERO (x18)</button>
            <button class="btn-opt" id="btn-par">PARIDAD (x2)</button>
            <button class="btn-opt" id="btn-rango">RANGO (x2)</button>
        </div>

        <button id="btn-spin">GIRAR</button>
        
        <div class="actions-secondary">
            <span class="link-action" id="btn-energy">‚ö° Recargar Energ√≠a (20$)</span>
            <span style="color:#444" id="display-energy">Energ√≠a: 5/5</span>
        </div>
    </div>

</div>

<script type="text/python">
from browser import document, window, html, timer
import math
import random

# --- CONFIGURACI√ìN GLOBAL ---
estado = {
    "puntos": 1000,
    "energia": 5,
    "costo_energia": 20,
    "racha_wins": 0,
    "tipo_apuesta": "exacto", # exacto, par, rango
    "girando": False,
    "reel_y": 0.0,    # Posici√≥n vertical absoluta (flotante para suavidad)
    "velocidad": 0.0, # Velocidad actual en px/frame
    "objetivo": None  # N√∫mero objetivo (None cuando no est√° decidido)
}

# Configuraci√≥n del Canvas
canvas = document["reel-canvas"]
ctx = canvas.getContext("2d")
NUMEROS = list(range(1, 21)) # 1 al 20
ITEM_H = 80  # Altura de cada n√∫mero
W, H = canvas.width, canvas.height

# --- L√ìGICA GR√ÅFICA (MOTOR DE F√çSICA) ---

def render_loop():
    """ Renderiza el carrete basado en estado['reel_y'] """
    ctx.clearRect(0, 0, W, H)
    
    # Fondo oscuro del tambor
    ctx.fillStyle = "#050505"
    ctx.fillRect(0, 0, W, H)

    cy = H / 2  # Centro Y del canvas
    
    # Determinar qu√© √≠ndices dibujar (Optimizaci√≥n: solo visibles)
    # Convertimos la posici√≥n Y absoluta a √≠ndice virtual
    idx_central_virtual = estado['reel_y'] / ITEM_H
    
    # Dibujamos un rango alrededor del centro
    inicio = int(idx_central_virtual) - 3
    fin = int(idx_central_virtual) + 4

    # Efecto de estiramiento por velocidad (Motion Stretch)
    stretch = 1.0 + (abs(estado['velocidad']) * 0.005)
    if stretch > 1.8: stretch = 1.8 # Limitar estiramiento

    ctx.textAlign = "center"
    ctx.textBaseline = "middle"

    for i in range(inicio, fin + 1):
        # Mapear el √≠ndice infinito al array real (1-20)
        num_idx = i % len(NUMEROS)
        num_val = NUMEROS[num_idx]
        
        # Posici√≥n Y relativa al centro
        y_pos = (i * ITEM_H) - estado['reel_y'] + cy
        
        # Distancia al centro (0 a 1) para efectos 3D
        dist = abs(y_pos - cy) / (H / 1.8)
        if dist > 1: dist = 1
        
        # Efectos visuales basados en distancia (Efecto Cilindro)
        scale = (1.0 - (dist * 0.4)) # M√°s peque√±o en los bordes
        alpha = 1.0 - (dist * 0.9)   # M√°s transparente en los bordes
        
        # Si est√° girando muy r√°pido, reducir alfa para ayudar al motion blur
        if abs(estado['velocidad']) > 20:
            alpha *= 0.7

        if alpha < 0: alpha = 0

        # Configuraci√≥n de fuente y color
        ctx.save()
        
        # Transformaci√≥n para estiramiento vertical (Velocidad)
        ctx.translate(W/2, y_pos)
        ctx.scale(1, stretch * scale) 
        
        # Color: Si est√° cerca del centro, es ORO brillante, si no, gris met√°lico
        if dist < 0.15:
            ctx.fillStyle = f"rgba(255, 215, 0, {alpha})"
            ctx.shadowColor = "#d4af37"
            ctx.shadowBlur = 20
            font_w = "900"
        else:
            ctx.fillStyle = f"rgba(180, 180, 180, {alpha})"
            ctx.shadowBlur = 0
            font_w = "400"

        ctx.font = f"{font_w} 40px 'Cinzel'"
        ctx.fillText(str(num_val), 0, 0)
        
        ctx.restore()

def physics_loop():
    """ Loop principal de f√≠sica y l√≥gica de parada """
    if not estado['girando'] and estado['velocidad'] == 0:
        return

    # 1. Aplicar Fricci√≥n (simula peso)
    if estado['objetivo'] is None:
        # Fase de aceleraci√≥n o giro libre
        pass 
    else:
        # Fase de aterrizaje: Calcular distancia al objetivo
        idx_target = NUMEROS.index(estado['objetivo'])
        
        # Calcular posici√≥n Y objetivo (queremos que quede en el centro)
        # Necesitamos encontrar el m√∫ltiplo de vueltas m√°s cercano hacia adelante
        actual_idx_aprox = estado['reel_y'] / ITEM_H
        vueltas = math.ceil(actual_idx_aprox / 20)
        if vueltas < actual_idx_aprox / 20: vueltas += 1 # Asegurar que sea futuro
        
        target_y = (vueltas * 20 * ITEM_H) + (idx_target * ITEM_H)
        
        # Si estamos demasiado cerca, dar otra vuelta para que la frenada sea suave
        distancia = target_y - estado['reel_y']
        if distancia < ITEM_H * 10: 
            target_y += (20 * ITEM_H)
            distancia += (20 * ITEM_H)
            
        # Algoritmo de aproximaci√≥n suave (PD Controller simple)
        kp = 0.05 # Fuerza de atracci√≥n
        error = target_y - estado['reel_y']
        
        if error < 1 and abs(estado['velocidad']) < 1:
            # STOP FINAL
            estado['reel_y'] = target_y
            estado['velocidad'] = 0
            estado['girando'] = False
            estado['objetivo'] = None
            render_loop()
            resolver_apuesta(NUMEROS[idx_target])
            return
        
        # Ajustar velocidad para llegar al punto
        velocidad_deseada = error * kp
        # Limitar velocidad m√°xima para que no salte instant√°neo
        if velocidad_deseada > 60: velocidad_deseada = 60
        
        # Interpolaci√≥n de velocidad (Suavizado)
        estado['velocidad'] += (velocidad_deseada - estado['velocidad']) * 0.1

    # 2. Aplicar Velocidad
    estado['reel_y'] += estado['velocidad']
    
    # 3. Renderizar y pedir siguiente frame
    render_loop()
    window.requestAnimationFrame(lambda t: physics_loop())

# --- L√ìGICA DE JUEGO ---

def actualizar_ui():
    # Animaci√≥n num√©rica simple
    document['display-puntos'].text = f"{int(estado['puntos'])}"
    document['display-energy'].text = f"Energ√≠a: {estado['energia']}/5"
    
    streak = estado['racha_wins']
    mult = 1.0 + (streak * 0.5) if streak > 1 else 1.0
    badge = document['display-streak']
    badge.text = f"RACHA: x{mult}"
    
    if streak >= 2:
        badge.classList.add('streak-active')
    else:
        badge.classList.remove('streak-active')

def cambiar_tab(ev):
    btn = ev.target
    # Reset tabs
    for b in ['btn-exacto', 'btn-par', 'btn-rango']:
        document[b].classList.remove('active')
    btn.classList.add('active')
    
    tipo = btn.id.split('-')[1]
    estado['tipo_apuesta'] = tipo
    
    sel = document['input-subopcion']
    sel.html = "" # Limpiar
    
    if tipo == "exacto":
        for i in range(1, 21): sel <= html.OPTION(f"{i}", value=i)
    elif tipo == "par":
        sel <= html.OPTION("PAR (2,4,6...)", value="par")
        sel <= html.OPTION("IMPAR (1,3,5...)", value="impar")
    elif tipo == "rango":
        sel <= html.OPTION("BAJO (1-10)", value="bajo")
        sel <= html.OPTION("ALTO (11-20)", value="alto")

def girar(ev):
    if estado['girando']: return
    
    try:
        monto = int(document['input-monto'].value)
    except:
        return
        
    if monto > estado['puntos']:
        document['mensaje'].text = "üö´ Fondos insuficientes"
        document['mensaje'].style.color = "#ff2a2a"
        return
    
    if estado['energia'] <= 0:
        document['mensaje'].text = "üö´ Sin energ√≠a. Recarga abajo."
        return

    # Iniciar Transacci√≥n
    estado['puntos'] -= monto
    estado['energia'] -= 1
    actualizar_ui()
    
    # Iniciar F√≠sica
    estado['girando'] = True
    estado['velocidad'] = 50 # Impulso inicial fuerte
    document['mensaje'].text = "üé≤ La suerte est√° echada..."
    document['mensaje'].style.color = "#d4af37"
    
    physics_loop()
    
    # Decidir resultado despu√©s de un breve delay (simulando latencia de servidor)
    # Esto permite que el carrete gire libremente un momento antes de saber d√≥nde parar
    def decidir_parada():
        ganador = random.randint(1, 20)
        estado['objetivo'] = ganador # Esto activa la fase de frenado en physics_loop
        
    timer.set_timeout(decidir_parada, 1500) # 1.5 seg de giro libre

def resolver_apuesta(resultado):
    monto = int(document['input-monto'].value)
    eleccion = document['input-subopcion'].value
    tipo = estado['tipo_apuesta']
    gano = False
    
    # Calcular Multiplicador de Racha
    mult_racha = 1.0 + (estado['racha_wins'] * 0.5) if estado['racha_wins'] > 1 else 1.0
    if mult_racha > 3.0: mult_racha = 3.0 # Cap max

    premio_base = 0
    
    if tipo == "exacto":
        if str(resultado) == str(eleccion):
            premio_base = monto * 18 # House edge ajustado
            gano = True
    elif tipo == "par":
        es_par = (resultado % 2 == 0)
        if (eleccion == "par" and es_par) or (eleccion == "impar" and not es_par):
            premio_base = monto * 2
            gano = True
    elif tipo == "rango":
        if (eleccion == "bajo" and 1 <= resultado <= 10) or (eleccion == "alto" and 11 <= resultado <= 20):
            premio_base = monto * 2
            gano = True

    if gano:
        premio_total = int(premio_base * mult_racha)
        estado['puntos'] += premio_total
        estado['racha_wins'] += 1
        
        texto_racha = f" (x{mult_racha} COMBO)" if mult_racha > 1 else ""
        document['mensaje'].text = f"üî• ¬°GANASTE {premio_total}! {texto_racha}"
        document['mensaje'].style.color = "#00f3ff" # Neon Blue
        
        # Efecto Confetti
        window.confetti({'particleCount': 100, 'spread': 70, 'origin': {'y': 0.6}, 'colors': ['#d4af37', '#00f3ff']})
    else:
        estado['racha_wins'] = 0 # Reset racha
        document['mensaje'].text = f"‚ùå Sali√≥ {resultado}. Intenta de nuevo."
        document['mensaje'].style.color = "#aaa"
        
        # Check Bancarrota
        if estado['puntos'] < 10:
            document['mensaje'].text = "üíÄ BANCARROTA. (Te prestamos 50...)"
            estado['puntos'] += 50
    
    actualizar_ui()

def recargar(ev):
    if estado['puntos'] >= estado['costo_energia']:
        estado['puntos'] -= estado['costo_energia']
        estado['energia'] += 1
        # Inflaci√≥n simple: cada compra cuesta m√°s si tienes muchas cargas
        if estado['energia'] > 5: estado['costo_energia'] += 10 
        
        actualizar_ui()
        document['mensaje'].text = "‚ö° Energ√≠a recargada"
    else:
        document['mensaje'].text = "üö´ Fondos insuficientes para recarga"

# Eventos
document['btn-spin'].bind('click', girar)
document['btn-energy'].bind('click', recargar)
document['btn-exacto'].bind('click', cambiar_tab)
document['btn-par'].bind('click', cambiar_tab)
document['btn-rango'].bind('click', cambiar_tab)

# Init
# Forzar click inicial para llenar el select
cambiar_tab(type('obj', (object,), {'target': document['btn-exacto']}))
render_loop()

</script>
</body>
</html>